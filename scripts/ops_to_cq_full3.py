#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ops_to_cq_codegen.py
Read an ops.json and GENERATE a self-contained CadQuery script that recreates
the sketch as Lines/Arcs/Circles, assembles wires, finds faces (with holes),
and extrudes (either solids or a plate-with-holes). The generated code does
NOT parse JSON; it uses hard-coded numeric primitives.

Example:
  python3 scripts/ops_to_cq_codegen.py filtered_dataset/.../ops.json > out_cq.py
  python3 scripts/ops_to_cq_codegen.py ops.json --out-py out_cq.py
"""

import argparse, json, sys, os
from math import cos, sin, atan2, degrees

def parse_args():
    p = argparse.ArgumentParser(description="Generate CadQuery code from ops.json")
    p.add_argument("ops_json", help="Path to ops.json (list or {'ops': [...]})")
    p.add_argument("--out-py", default=None, help="Write generated CadQuery code here (else stdout)")
    p.add_argument("--mode", choices=["solids","plate"], default="solids",
                   help="Default EXTRUDE_MODE baked into generated code.")
    p.add_argument("--height", type=float, default=0.008, help="Solid height (m) when mode=solids.")
    p.add_argument("--plate-thick", type=float, default=0.004, help="Plate thickness (m) when mode=plate.")
    p.add_argument("--margin", type=float, default=0.002, help="Plate margin around loops (m) when mode=plate.")
    p.add_argument("--tol-edge", type=float, default=1e-9, help="Degenerate edge tolerance baked in.")
    p.add_argument("--tol-close", type=float, default=1e-6, help="Auto-bridge gap tolerance baked in.")
    p.add_argument("--no-bridge", action="store_true", help="Disable auto-bridge (baked into generated code).")
    p.add_argument("--debug", action="store_true", help="Print a summary while generating.")
    return p.parse_args()

def load_ops(path):
    with open(path, "r") as f:
        data = json.load(f)
    if isinstance(data, dict) and "ops" in data:
        ops = data["ops"]
    else:
        ops = data
    if not isinstance(ops, list):
        raise ValueError("ops_json must be a list or a dict with key 'ops'.")
    return ops

# ---- math helpers (for codegen of arcs) ----
def _world_angles_from_local(xdir, ydir, a0, a1):
    # xdir=(xdx,xdy), ydir=(ydx,ydy) is orthonormal in 2D; angles returned in degrees
    xdx, xdy = xdir
    ydx, ydy = ydir
    def world_angle(a):
        vx = cos(a)*xdx + sin(a)*ydx
        vy = cos(a)*xdy + sin(a)*ydy
        return degrees(atan2(vy, vx))
    return world_angle(a0), world_angle(a1)

def gen_header(mode, height, plate_thick, margin, tol_edge, tol_close, bridge_enabled):
    # One unified helper suite (robust across CadQuery versions)
    return f'''# Auto-generated by ops_to_cq_codegen.py
import cadquery as cq
from math import cos, sin, atan2, degrees

# ------------- Config baked into this script -------------
EXTRUDE_MODE   = "{mode}"        # "solids" or "plate"
SOLID_HEIGHT   = {height}        # m
PLATE_THICK    = {plate_thick}   # m
PLATE_MARGIN   = {margin}        # m
TOL_EDGE       = {tol_edge}
TOL_CLOSE      = {tol_close}
BRIDGE_GAPS    = {str(bridge_enabled)}  # auto-bridge tiny end gaps
PRINT_DEBUG    = True

# ------------- Helpers -------------
def V(x, y, z=0.0): 
    return cq.Vector(float(x), float(y), float(z))

def dbg(*a):
    if PRINT_DEBUG:
        print(*a)

def edge_ok(e, tol=TOL_EDGE):
    # robust non-degenerate check without .length()
    try:
        sp, ep = e.startPoint(), e.endPoint()
        if (V(*sp.toTuple()) - V(*ep.toTuple())).Length > tol:
            return True
    except Exception:
        pass
    try:
        b = e.BoundingBox()
        span = max(b.xmax - b.xmin, b.ymax - b.ymin, b.zmax - b.zmin)
        return span > tol
    except Exception:
        return True

def _to_wire_list(obj):
    if obj is None:
        return []
    if isinstance(obj, cq.Wire):
        return [obj]
    if isinstance(obj, cq.Edge):
        return _to_wire_list(cq.Wire.assembleEdges([obj]))
    if isinstance(obj, (list, tuple)):
        out = []
        for it in obj:
            if isinstance(it, cq.Wire):
                out.append(it)
            elif isinstance(it, cq.Edge):
                out.extend(_to_wire_list(cq.Wire.assembleEdges([it])))
        return out
    return []

def assemble_closed_wires(edges, direct_wires):
    try:
        assembled = cq.Wire.assembleEdges(edges) if edges else []
        wires_all = _to_wire_list(assembled)
    except Exception as ex:
        dbg("assembleEdges(all) failed → fallback:", ex)
        wires_all = []
        for e in edges:
            try:
                wires_all.extend(_to_wire_list(cq.Wire.assembleEdges([e])))
            except Exception as ex2:
                dbg("assembleEdges(single) failed:", ex2)
    closed = []
    for w in wires_all + list(direct_wires):
        try:
            if w.isClosed():
                closed.append(w)
        except Exception:
            try:
                sp = V(*w.startPoint().toTuple()); ep = V(*w.endPoint().toTuple())
                if (sp-ep).Length <= TOL_CLOSE:
                    closed.append(w)
            except:
                pass
    return closed, wires_all

def close_small_gaps(edges, wires_all):
    added = False
    for w in wires_all:
        try:
            if w.isClosed(): 
                continue
        except:
            pass
        try:
            sp = V(*w.startPoint().toTuple()); ep = V(*w.endPoint().toTuple())
        except Exception:
            continue
        gap = (sp - ep).Length
        if 0 < gap <= TOL_CLOSE:
            edges.append(cq.Edge.makeLine(ep, sp))
            added = True
    if added:
        dbg(f"[auto-close] bridged gaps ≤ {{TOL_CLOSE}}")
        return assemble_closed_wires(edges, [])
    return [], wires_all

def wires_bbox_area(w):
    b = w.BoundingBox()
    return (b.xmax - b.xmin) * (b.ymax - b.ymin)

def group_outer_and_holes(closed_wires):
    wires_sorted = sorted(closed_wires, key=wires_bbox_area, reverse=True)
    groups = []  # [ [outer, [holes]], ... ]
    for w in wires_sorted:
        placed = False
        bb = w.BoundingBox()
        for outer, holes in groups:
            ob = outer.BoundingBox()
            if (bb.xmin >= ob.xmin - 1e-9 and bb.ymin >= ob.ymin - 1e-9 and
                bb.xmax <= ob.xmax + 1e-9 and bb.ymax <= ob.ymax + 1e-9):
                holes.append(w); placed=True; break
        if not placed:
            groups.append([w, []])
    return groups

def faces_from_groups(groups):
    faces = []
    for outer, holes in groups:
        try:
            if holes:
                faces.append(cq.Face.makeFromWires(outer, holes))
            else:
                faces.append(cq.Face.makeFromWires(outer))
        except Exception as ex:
            dbg("Face failed:", ex)
    return faces

def extrude_faces_union(faces, height):
    solids = []
    for f in faces:
        try:
            solids.append(cq.Workplane(obj=f).extrude(height).val())
        except Exception as ex:
            dbg("Extrude failed:", ex)
    if not solids:
        return None
    return cq.Workplane().newObject(solids).combine().val()

def bbox_of_wires(wires):
    if not wires:
        return None
    bb = None
    for w in wires:
        b = w.BoundingBox()
        if bb is None:
            bb = [b.xmin, b.ymin, b.xmax, b.ymax]
        else:
            bb[0] = min(bb[0], b.xmin)
            bb[1] = min(bb[1], b.ymin)
            bb[2] = max(bb[2], b.xmax)
            bb[3] = max(bb[3], b.ymax)
    return bb

# ---------- BEGIN PRIMITIVES (generated below) ----------
edges = []
direct_wires = []
'''

def gen_line_edge(p):
    dx, dy = float(p["dirX"]), float(p["dirY"])
    px, py = float(p["pntX"]), float(p["pntY"])
    t0, t1 = float(p["startParam"]), float(p["endParam"])
    x0, y0 = px + dx*t0, py + dy*t0
    x1, y1 = px + dx*t1, py + dy*t1
    return f'edges.append(cq.Edge.makeLine(V({x0:.17g}, {y0:.17g}), V({x1:.17g}, {y1:.17g})))\n'

def gen_arc_edge(p):
    cx, cy = float(p["xCenter"]), float(p["yCenter"])
    R  = float(p["radius"])
    xdx, xdy = float(p["xDir"]), float(p["yDir"])
    ydx, ydy = -xdy, xdx
    a0, a1  = float(p["startParam"]), float(p["endParam"])
    ang0, ang1 = _world_angles_from_local((xdx,xdy),(ydx,ydy), a0, a1)
    return (
        f'edges.append(cq.Edge.makeCircle({R:.17g}, V({cx:.17g}, {cy:.17g}), '
        f'cq.Vector(0,0,1), {ang0:.12g}, {ang1:.12g}))\n'
    )

def gen_circle_wire(p):
    cx, cy = float(p["xCenter"]), float(p["yCenter"])
    R  = float(p["radius"])
    return f'direct_wires.append(cq.Wire.makeCircle({R:.17g}, V({cx:.17g}, {cy:.17g}), cq.Vector(0,0,1)))\n'

def gen_footer():
    return '''# ---------- END PRIMITIVES ----------

# Optional tiny-gap bridging (close nearly-closed loops)
closed_wires, all_wires = assemble_closed_wires(edges, direct_wires)
if BRIDGE_GAPS and not closed_wires:
    closed_wires, all_wires = close_small_gaps(edges, all_wires)

dbg(f"edges={{len(edges)}} | direct_wires(circles)={{len(direct_wires)}} | wires(all)={{len(all_wires)}} | closed={{len(closed_wires)}}")

groups = group_outer_and_holes(closed_wires)
faces  = faces_from_groups(groups)
dbg(f"wire_groups={{len(groups)}} | faces={{len(faces)}}")

result = None
if EXTRUDE_MODE == "solids":
    result = extrude_faces_union(faces, SOLID_HEIGHT)

elif EXTRUDE_MODE == "plate":
    bb = bbox_of_wires(closed_wires)
    if bb:
        xmin, ymin, xmax, ymax = bb
        w = (xmax - xmin) + 2*PLATE_MARGIN
        h = (ymax - ymin) + 2*PLATE_MARGIN
        cx = 0.5*(xmin + xmax)
        cy = 0.5*(ymin + ymax)
        plate = (cq.Workplane("XY")
                 .center(cx, cy)
                 .rect(w, h)
                 .extrude(PLATE_THICK)
                 .val())
        cutters = []
        for f in faces:
            try:
                cutters.append(cq.Workplane(obj=f).extrude(PLATE_THICK + 1e-3).val())
            except Exception as ex:
                dbg("Cutter extrude failed:", ex)
        if cutters:
            cutters_combined = cq.Workplane().newObject(cutters).combine().val()
            result = plate.cut(cutters_combined)
        else:
            result = plate

# Show something in CQ-Editor if run interactively
show_object(cq.Workplane(obj=result) if result else cq.Workplane())
'''

def main():
    args = parse_args()
    ops = load_ops(args.ops_json)

    # Build the generated code
    code_parts = []
    code_parts.append(
        gen_header(
            mode=args.mode,
            height=args.height,
            plate_thick=args.plate_thick,
            margin=args.margin,
            tol_edge=args.tol_edge,
            tol_close=args.tol_close,
            bridge_enabled=(not args.no_bridge),
        )
    )

    # Convert ops into explicit primitives
    for n in ops:
        if n.get("kind") != "NodeOp":
            continue
        label = n.get("label","")
        p = (n.get("parameters") or {})
        if p.get("isConstruction", False):
            continue
        if label == "Line":
            code_parts.append(gen_line_edge(p))
        elif label == "Arc":
            code_parts.append(gen_arc_edge(p))
        elif label == "Circle":
            code_parts.append(gen_circle_wire(p))
        # points/constraints ignored

    code_parts.append(gen_footer())
    code = "".join(code_parts)

    # Output
    if args.out_py:
        os.makedirs(os.path.dirname(os.path.abspath(args.out_py)), exist_ok=True)
        with open(args.out_py, "w") as f:
            f.write(code)
        if args.debug:
            print(f"Wrote CadQuery code → {args.out_py}")
    else:
        sys.stdout.write(code)

if __name__ == "__main__":
    main()
